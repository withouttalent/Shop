{"version":3,"sources":["../src/index.js"],"names":["close","message","open","createWebSocketMiddleware","trimUndefined","CLOSE","MESSAGE","OPEN","SEND","type","payload","DEFAULT_OPTIONS","binaryType","fold","action","webSocket","meta","arrayify","send","some","actionWithoutMeta","JSON","stringify","namespace","unfold","raw","tryParseJSON","obj","Array","isArray","urlOrFactory","options","toLowerCase","WebSocket","onopen","store","dispatch","onclose","onmessage","getPayload","Blob","event","data","ArrayBuffer","Promise","resolve","then","Error","next","json","parse","err","map","Object","keys","reduce","nextMap","key","value"],"mappings":"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","file":"index.js","sourcesContent":["import blobToArrayBuffer from './blobToArrayBuffer';\r\nimport isFSA             from './isFSA';\r\n\r\nexport const CLOSE   = `CLOSE`;\r\nexport const MESSAGE = `MESSAGE`;\r\nexport const OPEN    = `OPEN`;\r\nexport const SEND    = `SEND`;\r\n\r\nexport function close() {\r\n  return { type: CLOSE };\r\n}\r\n\r\nexport function message(payload) {\r\n  return { type: MESSAGE, payload }\r\n}\r\n\r\nexport function open() {\r\n  return { type: OPEN };\r\n}\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  binaryType: 'arraybuffer',\r\n  fold      : (action, webSocket) => {\r\n    if (action.meta && arrayify(action.meta.send).some(send => send === true || send === webSocket)) {\r\n      const { meta, ...actionWithoutMeta } = action;\r\n\r\n      return JSON.stringify(actionWithoutMeta);\r\n    }\r\n  },\r\n  meta      : {},\r\n  namespace : '@@websocket/',\r\n  unfold   : (payload, webSocket, raw) => {\r\n    const action = tryParseJSON(payload);\r\n\r\n    return action && {\r\n      ...action,\r\n      meta: {\r\n        ...action.meta,\r\n        webSocket\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nfunction arrayify(obj) {\r\n  return obj ? Array.isArray(obj) ? obj : [obj] : [];\r\n}\r\n\r\nexport default function createWebSocketMiddleware(urlOrFactory, options = DEFAULT_OPTIONS) {\r\n  options = { ...DEFAULT_OPTIONS, ...options };\r\n  options.binaryType = options.binaryType.toLowerCase();\r\n  options.unfold = options.unfold && (typeof options.unfold === 'function' ? options.unfold : DEFAULT_OPTIONS.unfold);\r\n\r\n  const { namespace } = options;\r\n\r\n  return store => {\r\n    let webSocket;\r\n\r\n    if (typeof urlOrFactory === 'function') {\r\n      webSocket = urlOrFactory();\r\n    } else {\r\n      webSocket = new WebSocket(urlOrFactory);\r\n    }\r\n\r\n    webSocket.onopen = () => store.dispatch({ type: `${ namespace }${ OPEN }`, meta: { webSocket } });\r\n    webSocket.onclose = () => store.dispatch({ type: `${ namespace }${ CLOSE }`, meta: { webSocket } });\r\n    webSocket.onmessage = event => {\r\n      let getPayload;\r\n\r\n      if (typeof Blob !== 'undefined' && options.binaryType === 'arraybuffer' && event.data instanceof Blob) {\r\n        getPayload = blobToArrayBuffer(event.data);\r\n      } else if (typeof ArrayBuffer !== 'undefined' && options.binaryType === 'blob' && event.data instanceof ArrayBuffer) {\r\n        getPayload = new Blob([event.data]);\r\n      } else {\r\n        // We make this a Promise because we might want to keep the sequence of dispatch, @@websocket/MESSAGE first, then unfold later.\r\n        getPayload = Promise.resolve(event.data);\r\n      }\r\n\r\n      return getPayload.then(payload => {\r\n        if (options.unfold) {\r\n          const action = options.unfold(payload, webSocket, payload);\r\n\r\n          if (action) {\r\n            if (!isFSA(action)) {\r\n              throw new Error('Unfolded action is not a Flux Standard Action compliant');\r\n            }\r\n\r\n            return action && store.dispatch(action);\r\n          }\r\n        }\r\n\r\n        store.dispatch({\r\n          type: `${ namespace }${ MESSAGE }`,\r\n          meta: { webSocket },\r\n          payload\r\n        });\r\n      });\r\n    }\r\n\r\n    return next => action => {\r\n      if (action.type === `${ namespace }${ SEND }`) {\r\n        webSocket.send(action.payload);\r\n      } else {\r\n        const payload = options.fold(action, webSocket);\r\n\r\n        payload && webSocket.send(payload);\r\n      }\r\n\r\n      return next(action);\r\n    };\r\n  };\r\n}\r\n\r\nfunction tryParseJSON(json) {\r\n  try {\r\n    return JSON.parse(json);\r\n  } catch (err) {}\r\n}\r\n\r\nexport function trimUndefined(map) {\r\n  return Object.keys(map).reduce((nextMap, key) => {\r\n    const value = map[key];\r\n\r\n    if (typeof value !== 'undefined') {\r\n      nextMap[key] = value;\r\n    }\r\n\r\n    return nextMap;\r\n  }, {});\r\n}\r\n"]}